<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Lean goal trace: ProofsWMathlib/Lean/day_2025_12_30.lean</title>

<!-- highlight.js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>

<style>
:root {
  color-scheme: light;
  --bg: #f6f7fb;
  --panel: #ffffff;
  --text: #1f2937;
  --muted: #6b7280;
  --code-bg: #f8fafc;
  --goal-bg: #f2f4f8;
  --accent: rgba(255, 208, 96, 0.45);
  --accent-strong: rgba(255, 184, 36, 0.7);
  --cursor: #0f172a;
  --border: #e5e7eb;
  --kw: #7c3aed;
  --const: #2563eb;
  --str: #dc2626;
  --comment: #6b7280;
  --num: #b45309;
}
body.theme-dark {
  color-scheme: dark;
  --bg: #0b0f19;
  --panel: #0f172a;
  --text: #e5e7eb;
  --muted: #9ca3af;
  --code-bg: #0a1020;
  --goal-bg: #0c1224;
  --accent: rgba(255, 214, 102, 0.35);
  --accent-strong: rgba(255, 198, 68, 0.55);
  --cursor: #f8fafc;
  --border: #1f2937;
  --kw: #c084fc;
  --const: #93c5fd;
  --str: #fb7185;
  --comment: #9ca3af;
  --num: #fbbf24;
}

  body {
    margin: 0; padding: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    display: grid;
    grid-template-columns: 1.4fr 1fr;
    height: 100vh;
    background: var(--bg);
    color: var(--text);
  }
  #left {
    border-right: 1px solid var(--border);
    overflow: auto;
    padding: 12px;
    background: var(--panel);
  }
  #right {
    overflow: auto;
    padding: 12px;
    background: var(--panel);
  }
  .meta {
    color: var(--muted);
    font-size: 12px;
    margin-bottom: 10px;
  }

  #toolbar {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-bottom: 8px;
  }
  .button {
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text);
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
  }
  .button:hover {
    background: var(--goal-bg);
  }

  /* Code pane */
  #codewrap {
    position: relative;
    background: var(--code-bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px;
  }
  pre {
    margin: 0;
    font-size: 13px;
    line-height: 1.42;
    white-space: normal;
  }
  code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    display: block;
    white-space: pre;
  }

  /* Cursor + selection */
  .line {
    display: flex;
    align-items: flex-start;
    position: relative;
    padding-left: 0;
    white-space: pre;
  }
  .ln {
    flex: 0 0 4.2em;
    color: var(--muted);
    user-select: none;
    text-align: right;
    padding-right: 0.7em;
  }
  .codeText {
    flex: 1;
    min-height: 1.2em;
    white-space: pre;
  }
  .seg {
    border-radius: 6px;
    padding: 0 2px;
  }
  .seg.hasGoal {
    background: none;
    box-shadow: inset 0 -1px var(--border);
  }
  .seg.active {
    outline: 2px solid var(--accent-strong);
    background: var(--accent-strong);
  }
  .seg.fallback {
    box-shadow: 0 0 0 1px var(--border) inset;
  }

  /* Fake cursor */
  #cursor {
    position: absolute;
    width: 2px;
    background: var(--cursor);
    pointer-events: none;
    display: none;
  }

  #goal {
    white-space: pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size: 13px;
    line-height: 1.4;
    background: var(--goal-bg);
    border-radius: 8px;
    padding: 10px;
    border: 1px solid var(--border);
    color: var(--text);
  }

  /* Syntax highlighting */
  .hljs-keyword { color: var(--kw); font-weight: 600; }
  .hljs-title, .hljs-type, .hljs-built_in { color: var(--const); }
  .hljs-string { color: var(--str); }
  .hljs-number { color: var(--num); }
  .hljs-comment { color: var(--comment); font-style: italic; }
</style>
</head>
<body class="theme-light">
  <div id="left">
    <div id="toolbar">
      <button class="button" id="themeToggle" type="button">Toggle theme</button>
    </div>
    <div class="meta">
      <div><b>File:</b> ProofsWMathlib/Lean/day_2025_12_30.lean</div>
      <div><b>Unique states:</b> 94 &nbsp; <b>Occurrences:</b> 251</div>
      <div>Click to place cursor. Use arrow keys to move. (Read-only)</div>
    </div>

    <div id="codewrap" tabindex="0" aria-label="Code view (read-only)">
      <div id="cursor"></div>
      <!-- code will be injected -->
    </div>
  </div>

  <div id="right">
    <div class="meta"><b>Goal state</b></div>
    <div id="where" class="meta">No selection.</div>
    <div id="goal">(click in the code pane)</div>
  </div>

<script id="trace-data" type="application/json">{"file": "ProofsWMathlib/Lean/day_2025_12_30.lean", "uri": "file:///home/anand/src/lean/ProofsWMathlib.lean/ProofsWMathlib/Lean/day_2025_12_30.lean", "mode": "dense", "unique_states": {"423430c75cf7dedf": "```lean\na : Sort u_1\nr : Setoid a\nx y z : a\nh : r x y ∧ r y z\n⊢ r x z\n```", "c2f430406fef1909": "```lean\na : Sort u_1\nr : Setoid a\nx y z : a\nhP : r x y\nhQ : r y z\n⊢ r x z\n```", "d7064e63adc3d44c": "no goals", "87d4e0783d863b17": "```lean\na : Sort u_1\nr : Setoid a\n⊢ ∀ (x : a), r x x\n```", "cbf4e95ac8443594": "```lean\na : Type u_1\nr : Setoid a\n⊢ ∅ ∉ r.classes\n```", "642270731809ad84": "```lean\na : Type u_1\nr : Setoid a\n⊢ ∀ (x : a), ¬∅ = {x_1 | r x_1 x}\n```", "4b5aa881f5ad7003": "```lean\na : Type u_1\nr : Setoid a\nx : a\n⊢ ¬∅ = {x_1 | r x_1 x}\n```", "3e70355ceabe5c9b": "```lean\na : Type u_1\nr : Setoid a\nx : a\nh : ∅ = {x_1 | r x_1 x}\n⊢ False\n```", "022870f1153733c1": "```lean\na : Type u_1\nr : Setoid a\nx : a\nh : ∅ = {x_1 | r x_1 x}\n⊢ x ∈ {x_1 | r x_1 x}\n```", "f69cb4a04584cf12": "```lean\na : Type u_1\nr : Setoid a\nx : a\nh : ∅ = {x_1 | r x_1 x}\nhx : x ∈ {x_1 | r x_1 x}\n⊢ False\n```", "21ee90b13dce56e7": "```lean\na : Type u_1\nr : Setoid a\nx : a\nh : ∅ = {x_1 | r x_1 x}\nhx : x ∈ {x_1 | r x_1 x}\n⊢ x ∈ ∅\n```", "2f2d558968373654": "```lean\na : Type u_1\nr : Setoid a\nx : a\nh : ∅ = {x_1 | r x_1 x}\nhx : x ∈ {x_1 | r x_1 x}\n⊢ x ∈ {x_1 | r x_1 x}\n```", "4a381481f316fb85": "```lean\na : Type u_1\nr : Setoid a\nx : a\nh : ∅ = {x_1 | r x_1 x}\nhx : x ∈ {x_1 | r x_1 x}\nhe : x ∈ ∅\n⊢ False\n```", "25fbb79192158283": "```lean\na : Type u_1\nr : Setoid a\n⊢ r.classes.PairwiseDisjoint id\n```", "94c567e874da4434": "```lean\na : Type u_1\nr : Setoid a\nhc : Setoid.IsPartition r.classes\n⊢ r.classes.PairwiseDisjoint id\n```", "5b0f43623bdf5acf": "```lean\na : Type u_1\nr : Setoid a\nhc : ∅ ∉ r.classes ∧ ∀ (a_1 : a), ∃! b, b ∈ r.classes ∧ a_1 ∈ b\n⊢ r.classes.PairwiseDisjoint id\n```", "97174ce8d49c20a8": "```lean\na : Type u_1\nx y : Set a\nz : a\nr : Setoid a\nh1 : x ∈ r.classes\nh2 : y ∈ r.classes\nhz : z ∈ x ∧ z ∈ y\n⊢ x = y\n```", "29b76b55fdf7c473": "```lean\na : Type u_1\nx y : Set a\nz : a\nr : Setoid a\nh1 : x ∈ r.classes\nh2 : y ∈ r.classes\ninx : z ∈ x\niny : z ∈ y\n⊢ x = y\n```", "344fbe88725e1e23": "```lean\na : Type u_1\ny : Set a\nz : a\nr : Setoid a\nh2 : y ∈ r.classes\niny : z ∈ y\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\n⊢ {x | r x a1} = y\n```", "a3f77cb519f9e180": "```lean\na : Type u_1\nx y : Set a\nz : a\nr : Setoid a\nh1 : x ∈ r.classes\nh2 : y ∈ r.classes\ninx : z ∈ x\niny : z ∈ y\n⊢ ?m.29\n```", "928beb8e2b40d0b3": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\n⊢ {x | r x a1} = {x | r x a2}\n```", "fd13b45f36bc1424": "```lean\na : Type u_1\ny : Set a\nz : a\nr : Setoid a\nh2 : y ∈ r.classes\niny : z ∈ y\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\n⊢ ?m.56\n```", "a4fe7596979d7c3f": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\n⊢ r z a1\n```", "f671e45f732256d1": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\n⊢ {x | r x a1} = {x | r x a2}\n```", "d87708d72d9e5fcb": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\n⊢ r z a2\n```", "5470057c0649466f": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\n⊢ {x | r x a1} = {x | r x a2}\n```", "31444a88aed1966a": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\n⊢ r a1 a2\n```", "29244e5cfd90b1fb": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\n⊢ {x | r x a1} = {x | r x a2}\n```", "63a8c0b647da790f": "```lean\ncase h\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\n⊢ xe ∈ {x | r x a1} ↔ xe ∈ {x | r x a2}\n```", "9b4aa98cb2e090a8": "```lean\ncase h.mp\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\n⊢ xe ∈ {x | r x a1} → xe ∈ {x | r x a2}\n```\n---\n```lean\ncase h.mpr\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\n⊢ xe ∈ {x | r x a2} → xe ∈ {x | r x a1}\n```", "b466df943c208b12": "```lean\ncase h.mp\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\n⊢ xe ∈ {x | r x a1} → xe ∈ {x | r x a2}\n```", "8b3e569aba0c276f": "```lean\ncase h.mp\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\nhxe : xe ∈ {x | r x a1}\n⊢ xe ∈ {x | r x a2}\n```", "82ae5d69689d39d4": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\nhxe : xe ∈ {x | r x a1}\n⊢ r xe a1\n```", "3511cd4a97d1055d": "```lean\ncase h.mp\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\nhxe : xe ∈ {x | r x a1}\nhxex : r xe a1\n⊢ xe ∈ {x | r x a2}\n```", "65fa206e2de0d4d8": "```lean\ncase h.mp\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\nhxe : xe ∈ {x | r x a1}\nhxex : r xe a1\n⊢ r xe a2\n```", "60615cdbd7203971": "```lean\ncase h.mpr\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\n⊢ xe ∈ {x | r x a2} → xe ∈ {x | r x a1}\n```", "aee9bcc27c1ac6b6": "```lean\ncase h.mpr\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\nhxe : xe ∈ {x | r x a2}\n⊢ xe ∈ {x | r x a1}\n```", "a49d7ce3bfef46c4": "```lean\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\nhxe : xe ∈ {x | r x a2}\n⊢ r xe a2\n```", "6aefb68b545a776c": "```lean\ncase h.mpr\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\nhxe : xe ∈ {x | r x a2}\nhxex : r xe a2\n⊢ xe ∈ {x | r x a1}\n```", "66d385643517d439": "```lean\ncase h.mpr\na : Type u_1\nz : a\nr : Setoid a\na1 : a\nh1 : {x | r x a1} ∈ r.classes\ninx : z ∈ {x | r x a1}\na2 : a\nh2 : {x | r x a2} ∈ r.classes\niny : z ∈ {x | r x a2}\nhzx : r z a1\nhzy : r z a2\nhxy : r a1 a2\nxe : a\nhxe : xe ∈ {x | r x a2}\nhxex : r xe a2\n⊢ r xe a1\n```", "daf25fdf9ee576c7": "```lean\na : Type u_1\nr : Setoid a\n⊢ ∀ (x : a), ∃ b ∈ r.classes, x ∈ b\n```", "2c6abf50d0c45114": "```lean\na : Type u_1\nr : Setoid a\nx : a\n⊢ ∃ b ∈ r.classes, x ∈ b\n```", "ff6915a7d0f489b6": "```lean\ncase h\na : Type u_1\nr : Setoid a\nx : a\n⊢ {z | r z x} ∈ r.classes ∧ x ∈ {z | r z x}\n```", "68b30d590be23b19": "```lean\ncase h.left\na : Type u_1\nr : Setoid a\nx : a\n⊢ {z | r z x} ∈ r.classes\n```\n---\n```lean\ncase h.right\na : Type u_1\nr : Setoid a\nx : a\n⊢ x ∈ {z | r z x}\n```", "2d48a259c9480e9d": "```lean\ncase h.left\na : Type u_1\nr : Setoid a\nx : a\n⊢ {z | r z x} ∈ r.classes\n```", "fecaafc217415352": "```lean\ncase h.left\na : Type u_1\nr : Setoid a\nx : a\n⊢ {z | r z x} ∈ {s | ∃ y, s = {x | r x y}}\n```", "627ede267eb3c56f": "```lean\ncase h.right\na : Type u_1\nr : Setoid a\nx : a\n⊢ x ∈ {z | r z x}\n```", "64c0ba5db5793169": "```lean\na : Type u_1\nr : Setoid a\n⊢ ∀ (x : a), ∃! b, b ∈ r.classes ∧ x ∈ b\n```", "a9cee73c5ef487ac": "```lean\na : Type u_1\nr : Setoid a\nx : a\n⊢ ∃! b, b ∈ r.classes ∧ x ∈ b\n```", "93f05608bef39e28": "```lean\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\n⊢ ∃! b, b ∈ r.classes ∧ x ∈ b\n```", "2675629fd00dcdee": "```lean\ncase refine_1\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\n⊢ (fun b ↦ b ∈ r.classes ∧ x ∈ b) b\n```\n---\n```lean\ncase refine_2\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\n⊢ ∀ (y : Set a), (fun b ↦ b ∈ r.classes ∧ x ∈ b) y → y = b\n```", "4729fbf52c4491b6": "```lean\ncase refine_1\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\n⊢ (fun b ↦ b ∈ r.classes ∧ x ∈ b) b\n```", "62662f84a4e8861e": "```lean\ncase refine_1\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\n⊢ b ∈ r.classes ∧ x ∈ b\n```", "1b9ca7745b4348e4": "```lean\ncase refine_2\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\n⊢ ∀ (y : Set a), (fun b ↦ b ∈ r.classes ∧ x ∈ b) y → y = b\n```", "79c94c1463a23e6c": "```lean\ncase refine_2\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\ny : Set a\n⊢ (fun b ↦ b ∈ r.classes ∧ x ∈ b) y → y = b\n```", "01f963752f304d2c": "```lean\ncase refine_2\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\ny : Set a\n⊢ y ∈ r.classes → x ∈ y → y = b\n```", "330eb996f77396d8": "```lean\ncase refine_2\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\ny : Set a\nhy : y ∈ r.classes\n⊢ x ∈ y → y = b\n```", "e220392fafd741c1": "```lean\ncase refine_2\na : Type u_1\nr : Setoid a\nx : a\nb : Set a\nhb_classes : b ∈ r.classes\nhxb : x ∈ b\ny : Set a\nhy : y ∈ r.classes\nhxe : x ∈ y\n⊢ y = b\n```", "56b12f4fe15bc13f": "```lean\na : Type u_1\nr : Setoid a\n⊢ Setoid.IsPartition r.classes\n```", "038712701bd5febf": "```lean\na : Type u_1\nr : Setoid a\n⊢ ∅ ∉ r.classes ∧ ∀ (a_1 : a), ∃! b, b ∈ r.classes ∧ a_1 ∈ b\n```", "db058e9dff2ffb6b": "```lean\ncase left\na : Type u_1\nr : Setoid a\n⊢ ∅ ∉ r.classes\n```\n---\n```lean\ncase right\na : Type u_1\nr : Setoid a\n⊢ ∀ (a_1 : a), ∃! b, b ∈ r.classes ∧ a_1 ∈ b\n```", "7a86b5f635442f3f": "```lean\ncase left\na : Type u_1\nr : Setoid a\n⊢ ∅ ∉ r.classes\n```", "10dd01a77fb6a9e9": "```lean\ncase right\na : Type u_1\nr : Setoid a\n⊢ ∀ (a_1 : a), ∃! b, b ∈ r.classes ∧ a_1 ∈ b\n```", "9221c75d86f21322": "```lean\nA : Sort u_1\nB : Sort u_2\nf : A → B\ninst✝ : Nonempty A\n⊢ Injective f ↔ HasLeftInverse f\n```", "39be14f0647176f8": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\ninst✝ : Nonempty A\n⊢ Injective f → HasLeftInverse f\n```\n---\n```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\ninst✝ : Nonempty A\n⊢ HasLeftInverse f → Injective f\n```", "d903e74ffa13cd9c": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\ninst✝ : Nonempty A\n⊢ Injective f → HasLeftInverse f\n```", "2a9016a1fb414b04": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\ninst✝ : Nonempty A\n⊢ HasLeftInverse f → Injective f\n```", "fdab68441ed3e727": "```lean\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\n⊢ Injective f ↔ HasLeftInverse f\n```", "e4e383677dc60a3d": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\n⊢ Injective f → HasLeftInverse f\n```\n---\n```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\n⊢ HasLeftInverse f → Injective f\n```", "1b6195e8d1f45843": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\n⊢ Injective f → HasLeftInverse f\n```", "75b19c49be27bda4": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhinj : Injective f\n⊢ HasLeftInverse f\n```", "b66b1040886e289a": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhinj : Injective f\ng : B → A := fun b ↦ if h : ∃ a, f a = b then Classical.choose h else Classical.choice hne\n⊢ HasLeftInverse f\n```", "0c387e37b7a9d2d0": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhinj : Injective f\ng : B → A := fun b ↦ if h : ∃ a, f a = b then Classical.choose h else Classical.choice hne\n⊢ LeftInverse g f\n```", "7183bc63afdab730": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhinj : Injective f\ng : B → A := fun b ↦ if h : ∃ a, f a = b then Classical.choose h else Classical.choice hne\na : A\n⊢ g (f a) = a\n```", "8cb216db13bb8c38": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhinj : Injective f\ng : B → A := fun b ↦ if h : ∃ a, f a = b then Classical.choose h else Classical.choice hne\na : A\nhex : ∃ a', f a' = f a\n⊢ g (f a) = a\n```", "95af6889654c2c3e": "```lean\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhinj : Injective f\ng : B → A := fun b ↦ if h : ∃ a, f a = b then Classical.choose h else Classical.choice hne\na : A\nhex : ∃ a', f a' = f a\n⊢ Classical.choose hex = a\n```", "4c2ed72e2677a520": "```lean\ncase a\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhinj : Injective f\ng : B → A := ⋯\na : A\nhex : ∃ a', f a' = f a\n⊢ f (Classical.choose hex) = f a\n```", "ba69ff8806490158": "```lean\ncase mp\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhinj : Injective f\ng : B → A := fun b ↦ if h : ∃ a, f a = b then Classical.choose h else Classical.choice hne\na : A\nhex : ∃ a', f a' = f a\nblorp : Classical.choose hex = a\n⊢ g (f a) = a\n```", "4356cb59f3bbbae9": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\n⊢ HasLeftInverse f → Injective f\n```", "5e8c531cd0f0de8b": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\nhl : HasLeftInverse f\n⊢ Injective f\n```", "b63034a5fd8eacdf": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg : LeftInverse g f\n⊢ Injective f\n```", "7cb37f14b0842cdc": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg hg_ : LeftInverse g f\n⊢ Injective f\n```", "ee691aebad17ed2c": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg : ∀ (x : A), g (f x) = x\nhg_ : LeftInverse g f\n⊢ Injective f\n```", "f3a8076d778fa4dd": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg : ∀ (x : A), g (f x) = x\nhg_ : LeftInverse g f\n⊢ ∀ ⦃a₁ a₂ : A⦄, f a₁ = f a₂ → a₁ = a₂\n```", "22e4121ab81f957b": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg : ∀ (x : A), g (f x) = x\nhg_ : LeftInverse g f\na1 a2 : A\nhf : f a1 = f a2\n⊢ a1 = a2\n```", "b46f8208ca17809e": "```lean\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg : ∀ (x : A), g (f x) = x\nhg_ : LeftInverse g f\na1 a2 : A\nhf : f a1 = f a2\n⊢ a1 = g (f a1)\n```", "439acedc0ff24ddd": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg : ∀ (x : A), g (f x) = x\nhg_ : LeftInverse g f\na1 a2 : A\nhf : f a1 = f a2\nfoo : a1 = g (f a1)\n⊢ a1 = a2\n```", "4e4a0aa986a6d300": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg : ∀ (x : A), g (f x) = x\nhg_ : LeftInverse g f\na1 a2 : A\nhf : f a1 = f a2\nfoo : a1 = g (f a2)\n⊢ a1 = a2\n```", "349c4e938b78daf0": "```lean\ncase mpr\nA : Sort u_1\nB : Sort u_2\nf : A → B\nhne : Nonempty A\ng : B → A\nhg : ∀ (x : A), g (f x) = x\nhg_ : LeftInverse g f\na1 a2 : A\nhf : f a1 = f a2\nfoo : a1 = a2\n⊢ a1 = a2\n```", "4a18d01fce05380e": "```lean\nA : Sort u_1\nh : ∃ x, True\n⊢ Nonempty A\n```", "9c046f2ee91fa5a0": "```lean\nA : Sort u_1\nh : ∃ x, True\nfoo : A\n⊢ Nonempty A\n```", "2f85c17004ccf947": "```lean\nA : Sort ?u.1236\nhne : Nonempty A\n⊢ A\n```", "052e79d7df0e3f68": "```lean\nA : Sort u_1\nB : Sort u_2\ng : B → A\nf : A → B\nh : LeftInverse g f\n⊢ Surjective g\n```", "903335d5c923e5f6": "```lean\nA : Sort u_1\nB : Sort u_2\ng : B → A\nf : A → B\nh : LeftInverse g f\na : A\n⊢ ∃ a_1, g a_1 = a\n```"}, "occurrences": [{"hash": "423430c75cf7dedf", "line": 12, "col_start": 85, "col_end": 87, "sample_pos": {"line": 12, "character": 85}}, {"hash": "423430c75cf7dedf", "line": 13, "col_start": 0, "col_end": 3, "sample_pos": {"line": 13, "character": 0}}, {"hash": "c2f430406fef1909", "line": 13, "col_start": 3, "col_end": 24, "sample_pos": {"line": 13, "character": 3}}, {"hash": "c2f430406fef1909", "line": 14, "col_start": 0, "col_end": 3, "sample_pos": {"line": 14, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 14, "col_start": 3, "col_end": 21, "sample_pos": {"line": 14, "character": 3}}, {"hash": "87d4e0783d863b17", "line": 16, "col_start": 57, "col_end": 59, "sample_pos": {"line": 16, "character": 57}}, {"hash": "87d4e0783d863b17", "line": 17, "col_start": 0, "col_end": 5, "sample_pos": {"line": 17, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 17, "col_start": 5, "col_end": 16, "sample_pos": {"line": 17, "character": 5}}, {"hash": "cbf4e95ac8443594", "line": 19, "col_start": 59, "col_end": 61, "sample_pos": {"line": 19, "character": 59}}, {"hash": "cbf4e95ac8443594", "line": 20, "col_start": 0, "col_end": 3, "sample_pos": {"line": 20, "character": 0}}, {"hash": "642270731809ad84", "line": 20, "col_start": 3, "col_end": 23, "sample_pos": {"line": 20, "character": 3}}, {"hash": "642270731809ad84", "line": 21, "col_start": 0, "col_end": 3, "sample_pos": {"line": 21, "character": 0}}, {"hash": "4b5aa881f5ad7003", "line": 21, "col_start": 3, "col_end": 11, "sample_pos": {"line": 21, "character": 3}}, {"hash": "3e70355ceabe5c9b", "line": 22, "col_start": 0, "col_end": 12, "sample_pos": {"line": 22, "character": 0}}, {"hash": "3e70355ceabe5c9b", "line": 23, "col_start": 0, "col_end": 35, "sample_pos": {"line": 23, "character": 0}}, {"hash": "022870f1153733c1", "line": 23, "col_start": 35, "col_end": 37, "sample_pos": {"line": 23, "character": 35}}, {"hash": "022870f1153733c1", "line": 24, "col_start": 0, "col_end": 5, "sample_pos": {"line": 24, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 24, "col_start": 5, "col_end": 18, "sample_pos": {"line": 24, "character": 5}}, {"hash": "f69cb4a04584cf12", "line": 25, "col_start": 0, "col_end": 31, "sample_pos": {"line": 25, "character": 0}}, {"hash": "21ee90b13dce56e7", "line": 25, "col_start": 31, "col_end": 33, "sample_pos": {"line": 25, "character": 31}}, {"hash": "21ee90b13dce56e7", "line": 26, "col_start": 0, "col_end": 21, "sample_pos": {"line": 26, "character": 0}}, {"hash": "21ee90b13dce56e7", "line": 27, "col_start": 0, "col_end": 9, "sample_pos": {"line": 27, "character": 0}}, {"hash": "2f2d558968373654", "line": 27, "col_start": 9, "col_end": 10, "sample_pos": {"line": 27, "character": 9}}, {"hash": "2f2d558968373654", "line": 28, "col_start": 0, "col_end": 5, "sample_pos": {"line": 28, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 28, "col_start": 5, "col_end": 12, "sample_pos": {"line": 28, "character": 5}}, {"hash": "4a381481f316fb85", "line": 29, "col_start": 0, "col_end": 3, "sample_pos": {"line": 29, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 29, "col_start": 3, "col_end": 10, "sample_pos": {"line": 29, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 31, "col_start": 0, "col_end": 2, "sample_pos": {"line": 31, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 32, "col_start": 0, "col_end": 63, "sample_pos": {"line": 32, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 33, "col_start": 0, "col_end": 2, "sample_pos": {"line": 33, "character": 0}}, {"hash": "25fbb79192158283", "line": 34, "col_start": 80, "col_end": 82, "sample_pos": {"line": 34, "character": 80}}, {"hash": "25fbb79192158283", "line": 35, "col_start": 0, "col_end": 56, "sample_pos": {"line": 35, "character": 0}}, {"hash": "25fbb79192158283", "line": 36, "col_start": 0, "col_end": 40, "sample_pos": {"line": 36, "character": 0}}, {"hash": "25fbb79192158283", "line": 37, "col_start": 0, "col_end": 91, "sample_pos": {"line": 37, "character": 0}}, {"hash": "25fbb79192158283", "line": 38, "col_start": 0, "col_end": 3, "sample_pos": {"line": 38, "character": 0}}, {"hash": "94c567e874da4434", "line": 38, "col_start": 3, "col_end": 72, "sample_pos": {"line": 38, "character": 3}}, {"hash": "94c567e874da4434", "line": 39, "col_start": 0, "col_end": 3, "sample_pos": {"line": 39, "character": 0}}, {"hash": "5b0f43623bdf5acf", "line": 39, "col_start": 3, "col_end": 33, "sample_pos": {"line": 39, "character": 3}}, {"hash": "5b0f43623bdf5acf", "line": 40, "col_start": 0, "col_end": 3, "sample_pos": {"line": 40, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 40, "col_start": 3, "col_end": 7, "sample_pos": {"line": 40, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 41, "col_start": 0, "col_end": 2, "sample_pos": {"line": 41, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 43, "col_start": 0, "col_end": 88, "sample_pos": {"line": 43, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 45, "col_start": 0, "col_end": 49, "sample_pos": {"line": 45, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 47, "col_start": 0, "col_end": 93, "sample_pos": {"line": 47, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 49, "col_start": 0, "col_end": 14, "sample_pos": {"line": 49, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 51, "col_start": 0, "col_end": 2, "sample_pos": {"line": 51, "character": 0}}, {"hash": "97174ce8d49c20a8", "line": 53, "col_start": 40, "col_end": 42, "sample_pos": {"line": 53, "character": 40}}, {"hash": "97174ce8d49c20a8", "line": 54, "col_start": 0, "col_end": 3, "sample_pos": {"line": 54, "character": 0}}, {"hash": "29b76b55fdf7c473", "line": 54, "col_start": 3, "col_end": 27, "sample_pos": {"line": 54, "character": 3}}, {"hash": "29b76b55fdf7c473", "line": 56, "col_start": 0, "col_end": 3, "sample_pos": {"line": 56, "character": 0}}, {"hash": "344fbe88725e1e23", "line": 56, "col_start": 3, "col_end": 10, "sample_pos": {"line": 56, "character": 3}}, {"hash": "a3f77cb519f9e180", "line": 56, "col_start": 10, "col_end": 42, "sample_pos": {"line": 56, "character": 10}}, {"hash": "d7064e63adc3d44c", "line": 56, "col_start": 42, "col_end": 45, "sample_pos": {"line": 56, "character": 42}}, {"hash": "344fbe88725e1e23", "line": 56, "col_start": 45, "col_end": 60, "sample_pos": {"line": 56, "character": 45}}, {"hash": "344fbe88725e1e23", "line": 57, "col_start": 0, "col_end": 3, "sample_pos": {"line": 57, "character": 0}}, {"hash": "928beb8e2b40d0b3", "line": 57, "col_start": 3, "col_end": 10, "sample_pos": {"line": 57, "character": 3}}, {"hash": "fd13b45f36bc1424", "line": 57, "col_start": 10, "col_end": 42, "sample_pos": {"line": 57, "character": 10}}, {"hash": "d7064e63adc3d44c", "line": 57, "col_start": 42, "col_end": 45, "sample_pos": {"line": 57, "character": 42}}, {"hash": "928beb8e2b40d0b3", "line": 57, "col_start": 45, "col_end": 60, "sample_pos": {"line": 57, "character": 45}}, {"hash": "928beb8e2b40d0b3", "line": 59, "col_start": 0, "col_end": 23, "sample_pos": {"line": 59, "character": 0}}, {"hash": "a4fe7596979d7c3f", "line": 59, "col_start": 23, "col_end": 27, "sample_pos": {"line": 59, "character": 23}}, {"hash": "d7064e63adc3d44c", "line": 59, "col_start": 27, "col_end": 35, "sample_pos": {"line": 59, "character": 27}}, {"hash": "f671e45f732256d1", "line": 60, "col_start": 0, "col_end": 23, "sample_pos": {"line": 60, "character": 0}}, {"hash": "d87708d72d9e5fcb", "line": 60, "col_start": 23, "col_end": 27, "sample_pos": {"line": 60, "character": 23}}, {"hash": "d7064e63adc3d44c", "line": 60, "col_start": 27, "col_end": 35, "sample_pos": {"line": 60, "character": 27}}, {"hash": "5470057c0649466f", "line": 61, "col_start": 0, "col_end": 24, "sample_pos": {"line": 61, "character": 0}}, {"hash": "31444a88aed1966a", "line": 61, "col_start": 24, "col_end": 28, "sample_pos": {"line": 61, "character": 24}}, {"hash": "d7064e63adc3d44c", "line": 61, "col_start": 28, "col_end": 57, "sample_pos": {"line": 61, "character": 28}}, {"hash": "29244e5cfd90b1fb", "line": 63, "col_start": 0, "col_end": 3, "sample_pos": {"line": 63, "character": 0}}, {"hash": "63a8c0b647da790f", "line": 63, "col_start": 3, "col_end": 8, "sample_pos": {"line": 63, "character": 3}}, {"hash": "63a8c0b647da790f", "line": 64, "col_start": 0, "col_end": 3, "sample_pos": {"line": 64, "character": 0}}, {"hash": "9b4aa98cb2e090a8", "line": 64, "col_start": 3, "col_end": 13, "sample_pos": {"line": 64, "character": 3}}, {"hash": "9b4aa98cb2e090a8", "line": 66, "col_start": 0, "col_end": 3, "sample_pos": {"line": 66, "character": 0}}, {"hash": "b466df943c208b12", "line": 66, "col_start": 3, "col_end": 5, "sample_pos": {"line": 66, "character": 3}}, {"hash": "8b3e569aba0c276f", "line": 66, "col_start": 5, "col_end": 13, "sample_pos": {"line": 66, "character": 5}}, {"hash": "8b3e569aba0c276f", "line": 67, "col_start": 0, "col_end": 27, "sample_pos": {"line": 67, "character": 0}}, {"hash": "82ae5d69689d39d4", "line": 67, "col_start": 27, "col_end": 42, "sample_pos": {"line": 67, "character": 27}}, {"hash": "d7064e63adc3d44c", "line": 67, "col_start": 42, "col_end": 45, "sample_pos": {"line": 67, "character": 42}}, {"hash": "3511cd4a97d1055d", "line": 68, "col_start": 0, "col_end": 5, "sample_pos": {"line": 68, "character": 0}}, {"hash": "65fa206e2de0d4d8", "line": 68, "col_start": 5, "col_end": 18, "sample_pos": {"line": 68, "character": 5}}, {"hash": "65fa206e2de0d4d8", "line": 69, "col_start": 0, "col_end": 5, "sample_pos": {"line": 69, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 69, "col_start": 5, "col_end": 26, "sample_pos": {"line": 69, "character": 5}}, {"hash": "60615cdbd7203971", "line": 71, "col_start": 0, "col_end": 5, "sample_pos": {"line": 71, "character": 0}}, {"hash": "aee9bcc27c1ac6b6", "line": 71, "col_start": 5, "col_end": 13, "sample_pos": {"line": 71, "character": 5}}, {"hash": "aee9bcc27c1ac6b6", "line": 72, "col_start": 0, "col_end": 27, "sample_pos": {"line": 72, "character": 0}}, {"hash": "a49d7ce3bfef46c4", "line": 72, "col_start": 27, "col_end": 42, "sample_pos": {"line": 72, "character": 27}}, {"hash": "d7064e63adc3d44c", "line": 72, "col_start": 42, "col_end": 45, "sample_pos": {"line": 72, "character": 42}}, {"hash": "6aefb68b545a776c", "line": 73, "col_start": 0, "col_end": 5, "sample_pos": {"line": 73, "character": 0}}, {"hash": "66d385643517d439", "line": 73, "col_start": 5, "col_end": 18, "sample_pos": {"line": 73, "character": 5}}, {"hash": "66d385643517d439", "line": 74, "col_start": 0, "col_end": 5, "sample_pos": {"line": 74, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 74, "col_start": 5, "col_end": 35, "sample_pos": {"line": 74, "character": 5}}, {"hash": "daf25fdf9ee576c7", "line": 77, "col_start": 74, "col_end": 76, "sample_pos": {"line": 77, "character": 74}}, {"hash": "daf25fdf9ee576c7", "line": 78, "col_start": 0, "col_end": 3, "sample_pos": {"line": 78, "character": 0}}, {"hash": "2c6abf50d0c45114", "line": 78, "col_start": 3, "col_end": 9, "sample_pos": {"line": 78, "character": 3}}, {"hash": "2c6abf50d0c45114", "line": 79, "col_start": 0, "col_end": 26, "sample_pos": {"line": 79, "character": 0}}, {"hash": "2c6abf50d0c45114", "line": 80, "col_start": 0, "col_end": 63, "sample_pos": {"line": 80, "character": 0}}, {"hash": "2c6abf50d0c45114", "line": 81, "col_start": 0, "col_end": 3, "sample_pos": {"line": 81, "character": 0}}, {"hash": "ff6915a7d0f489b6", "line": 81, "col_start": 3, "col_end": 17, "sample_pos": {"line": 81, "character": 3}}, {"hash": "ff6915a7d0f489b6", "line": 82, "col_start": 0, "col_end": 3, "sample_pos": {"line": 82, "character": 0}}, {"hash": "68b30d590be23b19", "line": 82, "col_start": 3, "col_end": 13, "sample_pos": {"line": 82, "character": 3}}, {"hash": "68b30d590be23b19", "line": 83, "col_start": 0, "col_end": 3, "sample_pos": {"line": 83, "character": 0}}, {"hash": "2d48a259c9480e9d", "line": 83, "col_start": 3, "col_end": 9, "sample_pos": {"line": 83, "character": 3}}, {"hash": "fecaafc217415352", "line": 83, "col_start": 9, "col_end": 23, "sample_pos": {"line": 83, "character": 9}}, {"hash": "fecaafc217415352", "line": 84, "col_start": 0, "col_end": 5, "sample_pos": {"line": 84, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 84, "col_start": 5, "col_end": 9, "sample_pos": {"line": 84, "character": 5}}, {"hash": "627ede267eb3c56f", "line": 85, "col_start": 0, "col_end": 5, "sample_pos": {"line": 85, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 85, "col_start": 5, "col_end": 18, "sample_pos": {"line": 85, "character": 5}}, {"hash": "64c0ba5db5793169", "line": 87, "col_start": 77, "col_end": 79, "sample_pos": {"line": 87, "character": 77}}, {"hash": "64c0ba5db5793169", "line": 88, "col_start": 0, "col_end": 3, "sample_pos": {"line": 88, "character": 0}}, {"hash": "a9cee73c5ef487ac", "line": 88, "col_start": 3, "col_end": 9, "sample_pos": {"line": 88, "character": 3}}, {"hash": "a9cee73c5ef487ac", "line": 89, "col_start": 0, "col_end": 3, "sample_pos": {"line": 89, "character": 0}}, {"hash": "93f05608bef39e28", "line": 89, "col_start": 3, "col_end": 51, "sample_pos": {"line": 89, "character": 3}}, {"hash": "93f05608bef39e28", "line": 90, "col_start": 0, "col_end": 3, "sample_pos": {"line": 90, "character": 0}}, {"hash": "2675629fd00dcdee", "line": 90, "col_start": 3, "col_end": 20, "sample_pos": {"line": 90, "character": 3}}, {"hash": "2675629fd00dcdee", "line": 91, "col_start": 0, "col_end": 3, "sample_pos": {"line": 91, "character": 0}}, {"hash": "4729fbf52c4491b6", "line": 91, "col_start": 3, "col_end": 5, "sample_pos": {"line": 91, "character": 3}}, {"hash": "62662f84a4e8861e", "line": 91, "col_start": 5, "col_end": 32, "sample_pos": {"line": 91, "character": 5}}, {"hash": "62662f84a4e8861e", "line": 92, "col_start": 0, "col_end": 5, "sample_pos": {"line": 92, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 92, "col_start": 5, "col_end": 27, "sample_pos": {"line": 92, "character": 5}}, {"hash": "1b9ca7745b4348e4", "line": 93, "col_start": 0, "col_end": 5, "sample_pos": {"line": 93, "character": 0}}, {"hash": "79c94c1463a23e6c", "line": 93, "col_start": 5, "col_end": 11, "sample_pos": {"line": 93, "character": 5}}, {"hash": "79c94c1463a23e6c", "line": 94, "col_start": 0, "col_end": 5, "sample_pos": {"line": 94, "character": 0}}, {"hash": "01f963752f304d2c", "line": 94, "col_start": 5, "col_end": 8, "sample_pos": {"line": 94, "character": 5}}, {"hash": "01f963752f304d2c", "line": 95, "col_start": 0, "col_end": 5, "sample_pos": {"line": 95, "character": 0}}, {"hash": "330eb996f77396d8", "line": 95, "col_start": 5, "col_end": 14, "sample_pos": {"line": 95, "character": 5}}, {"hash": "e220392fafd741c1", "line": 95, "col_start": 14, "col_end": 16, "sample_pos": {"line": 95, "character": 14}}, {"hash": "e220392fafd741c1", "line": 96, "col_start": 0, "col_end": 5, "sample_pos": {"line": 96, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 96, "col_start": 5, "col_end": 59, "sample_pos": {"line": 96, "character": 5}}, {"hash": "56b12f4fe15bc13f", "line": 98, "col_start": 77, "col_end": 79, "sample_pos": {"line": 98, "character": 77}}, {"hash": "56b12f4fe15bc13f", "line": 99, "col_start": 0, "col_end": 7, "sample_pos": {"line": 99, "character": 0}}, {"hash": "038712701bd5febf", "line": 99, "col_start": 7, "col_end": 25, "sample_pos": {"line": 99, "character": 7}}, {"hash": "038712701bd5febf", "line": 100, "col_start": 0, "col_end": 3, "sample_pos": {"line": 100, "character": 0}}, {"hash": "db058e9dff2ffb6b", "line": 100, "col_start": 3, "col_end": 13, "sample_pos": {"line": 100, "character": 3}}, {"hash": "db058e9dff2ffb6b", "line": 101, "col_start": 0, "col_end": 3, "sample_pos": {"line": 101, "character": 0}}, {"hash": "7a86b5f635442f3f", "line": 101, "col_start": 3, "col_end": 5, "sample_pos": {"line": 101, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 101, "col_start": 5, "col_end": 28, "sample_pos": {"line": 101, "character": 5}}, {"hash": "10dd01a77fb6a9e9", "line": 102, "col_start": 0, "col_end": 5, "sample_pos": {"line": 102, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 102, "col_start": 5, "col_end": 25, "sample_pos": {"line": 102, "character": 5}}, {"hash": "9221c75d86f21322", "line": 129, "col_start": 38, "col_end": 40, "sample_pos": {"line": 129, "character": 38}}, {"hash": "9221c75d86f21322", "line": 130, "col_start": 0, "col_end": 3, "sample_pos": {"line": 130, "character": 0}}, {"hash": "39be14f0647176f8", "line": 130, "col_start": 3, "col_end": 13, "sample_pos": {"line": 130, "character": 3}}, {"hash": "39be14f0647176f8", "line": 131, "col_start": 0, "col_end": 3, "sample_pos": {"line": 131, "character": 0}}, {"hash": "d903e74ffa13cd9c", "line": 131, "col_start": 3, "col_end": 5, "sample_pos": {"line": 131, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 131, "col_start": 5, "col_end": 9, "sample_pos": {"line": 131, "character": 5}}, {"hash": "2a9016a1fb414b04", "line": 132, "col_start": 0, "col_end": 5, "sample_pos": {"line": 132, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 132, "col_start": 5, "col_end": 43, "sample_pos": {"line": 132, "character": 5}}, {"hash": "d7064e63adc3d44c", "line": 135, "col_start": 0, "col_end": 2, "sample_pos": {"line": 135, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 136, "col_start": 0, "col_end": 18, "sample_pos": {"line": 136, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 137, "col_start": 0, "col_end": 2, "sample_pos": {"line": 137, "character": 0}}, {"hash": "fdab68441ed3e727", "line": 139, "col_start": 38, "col_end": 40, "sample_pos": {"line": 139, "character": 38}}, {"hash": "fdab68441ed3e727", "line": 140, "col_start": 0, "col_end": 3, "sample_pos": {"line": 140, "character": 0}}, {"hash": "e4e383677dc60a3d", "line": 140, "col_start": 3, "col_end": 13, "sample_pos": {"line": 140, "character": 3}}, {"hash": "e4e383677dc60a3d", "line": 141, "col_start": 0, "col_end": 3, "sample_pos": {"line": 141, "character": 0}}, {"hash": "1b6195e8d1f45843", "line": 141, "col_start": 3, "col_end": 5, "sample_pos": {"line": 141, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 141, "col_start": 5, "col_end": 13, "sample_pos": {"line": 141, "character": 5}}, {"hash": "d7064e63adc3d44c", "line": 142, "col_start": 0, "col_end": 4, "sample_pos": {"line": 142, "character": 0}}, {"hash": "1b6195e8d1f45843", "line": 142, "col_start": 4, "col_end": 5, "sample_pos": {"line": 142, "character": 4}}, {"hash": "75b19c49be27bda4", "line": 142, "col_start": 5, "col_end": 14, "sample_pos": {"line": 142, "character": 5}}, {"hash": "75b19c49be27bda4", "line": 143, "col_start": 0, "col_end": 79, "sample_pos": {"line": 143, "character": 0}}, {"hash": "75b19c49be27bda4", "line": 144, "col_start": 0, "col_end": 86, "sample_pos": {"line": 144, "character": 0}}, {"hash": "75b19c49be27bda4", "line": 145, "col_start": 0, "col_end": 93, "sample_pos": {"line": 145, "character": 0}}, {"hash": "75b19c49be27bda4", "line": 146, "col_start": 0, "col_end": 5, "sample_pos": {"line": 146, "character": 0}}, {"hash": "b66b1040886e289a", "line": 146, "col_start": 5, "col_end": 21, "sample_pos": {"line": 146, "character": 5}}, {"hash": "b66b1040886e289a", "line": 147, "col_start": 0, "col_end": 33, "sample_pos": {"line": 147, "character": 0}}, {"hash": "b66b1040886e289a", "line": 148, "col_start": 0, "col_end": 43, "sample_pos": {"line": 148, "character": 0}}, {"hash": "b66b1040886e289a", "line": 149, "col_start": 0, "col_end": 45, "sample_pos": {"line": 149, "character": 0}}, {"hash": "b66b1040886e289a", "line": 150, "col_start": 0, "col_end": 57, "sample_pos": {"line": 150, "character": 0}}, {"hash": "b66b1040886e289a", "line": 151, "col_start": 0, "col_end": 57, "sample_pos": {"line": 151, "character": 0}}, {"hash": "b66b1040886e289a", "line": 152, "col_start": 0, "col_end": 92, "sample_pos": {"line": 152, "character": 0}}, {"hash": "b66b1040886e289a", "line": 153, "col_start": 0, "col_end": 55, "sample_pos": {"line": 153, "character": 0}}, {"hash": "b66b1040886e289a", "line": 154, "col_start": 0, "col_end": 5, "sample_pos": {"line": 154, "character": 0}}, {"hash": "0c387e37b7a9d2d0", "line": 154, "col_start": 5, "col_end": 18, "sample_pos": {"line": 154, "character": 5}}, {"hash": "0c387e37b7a9d2d0", "line": 155, "col_start": 0, "col_end": 5, "sample_pos": {"line": 155, "character": 0}}, {"hash": "7183bc63afdab730", "line": 155, "col_start": 5, "col_end": 11, "sample_pos": {"line": 155, "character": 5}}, {"hash": "7183bc63afdab730", "line": 156, "col_start": 0, "col_end": 5, "sample_pos": {"line": 156, "character": 0}}, {"hash": "8cb216db13bb8c38", "line": 156, "col_start": 5, "col_end": 47, "sample_pos": {"line": 156, "character": 5}}, {"hash": "8cb216db13bb8c38", "line": 158, "col_start": 0, "col_end": 59, "sample_pos": {"line": 158, "character": 0}}, {"hash": "8cb216db13bb8c38", "line": 159, "col_start": 0, "col_end": 54, "sample_pos": {"line": 159, "character": 0}}, {"hash": "8cb216db13bb8c38", "line": 160, "col_start": 0, "col_end": 45, "sample_pos": {"line": 160, "character": 0}}, {"hash": "95af6889654c2c3e", "line": 160, "col_start": 45, "col_end": 47, "sample_pos": {"line": 160, "character": 45}}, {"hash": "95af6889654c2c3e", "line": 161, "col_start": 0, "col_end": 7, "sample_pos": {"line": 161, "character": 0}}, {"hash": "4c2ed72e2677a520", "line": 161, "col_start": 7, "col_end": 16, "sample_pos": {"line": 161, "character": 7}}, {"hash": "4c2ed72e2677a520", "line": 162, "col_start": 0, "col_end": 47, "sample_pos": {"line": 162, "character": 0}}, {"hash": "4c2ed72e2677a520", "line": 163, "col_start": 0, "col_end": 18, "sample_pos": {"line": 163, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 163, "col_start": 18, "col_end": 45, "sample_pos": {"line": 163, "character": 18}}, {"hash": "ba69ff8806490158", "line": 165, "col_start": 0, "col_end": 6, "sample_pos": {"line": 165, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 165, "col_start": 6, "col_end": 17, "sample_pos": {"line": 165, "character": 6}}, {"hash": "ba69ff8806490158", "line": 166, "col_start": 0, "col_end": 5, "sample_pos": {"line": 166, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 166, "col_start": 5, "col_end": 24, "sample_pos": {"line": 166, "character": 5}}, {"hash": "4356cb59f3bbbae9", "line": 167, "col_start": 0, "col_end": 3, "sample_pos": {"line": 167, "character": 0}}, {"hash": "4356cb59f3bbbae9", "line": 168, "col_start": 0, "col_end": 84, "sample_pos": {"line": 168, "character": 0}}, {"hash": "4356cb59f3bbbae9", "line": 169, "col_start": 0, "col_end": 100, "sample_pos": {"line": 169, "character": 0}}, {"hash": "4356cb59f3bbbae9", "line": 170, "col_start": 0, "col_end": 91, "sample_pos": {"line": 170, "character": 0}}, {"hash": "4356cb59f3bbbae9", "line": 171, "col_start": 0, "col_end": 59, "sample_pos": {"line": 171, "character": 0}}, {"hash": "4356cb59f3bbbae9", "line": 172, "col_start": 0, "col_end": 98, "sample_pos": {"line": 172, "character": 0}}, {"hash": "4356cb59f3bbbae9", "line": 173, "col_start": 0, "col_end": 42, "sample_pos": {"line": 173, "character": 0}}, {"hash": "4356cb59f3bbbae9", "line": 175, "col_start": 0, "col_end": 5, "sample_pos": {"line": 175, "character": 0}}, {"hash": "5e8c531cd0f0de8b", "line": 175, "col_start": 5, "col_end": 12, "sample_pos": {"line": 175, "character": 5}}, {"hash": "5e8c531cd0f0de8b", "line": 176, "col_start": 0, "col_end": 5, "sample_pos": {"line": 176, "character": 0}}, {"hash": "b63034a5fd8eacdf", "line": 176, "col_start": 5, "col_end": 24, "sample_pos": {"line": 176, "character": 5}}, {"hash": "b63034a5fd8eacdf", "line": 177, "col_start": 0, "col_end": 5, "sample_pos": {"line": 177, "character": 0}}, {"hash": "7cb37f14b0842cdc", "line": 177, "col_start": 5, "col_end": 18, "sample_pos": {"line": 177, "character": 5}}, {"hash": "7cb37f14b0842cdc", "line": 178, "col_start": 0, "col_end": 9, "sample_pos": {"line": 178, "character": 0}}, {"hash": "ee691aebad17ed2c", "line": 178, "col_start": 9, "col_end": 26, "sample_pos": {"line": 178, "character": 9}}, {"hash": "ee691aebad17ed2c", "line": 179, "col_start": 0, "col_end": 9, "sample_pos": {"line": 179, "character": 0}}, {"hash": "f3a8076d778fa4dd", "line": 179, "col_start": 9, "col_end": 18, "sample_pos": {"line": 179, "character": 9}}, {"hash": "f3a8076d778fa4dd", "line": 180, "col_start": 0, "col_end": 5, "sample_pos": {"line": 180, "character": 0}}, {"hash": "22e4121ab81f957b", "line": 180, "col_start": 5, "col_end": 19, "sample_pos": {"line": 180, "character": 5}}, {"hash": "22e4121ab81f957b", "line": 181, "col_start": 0, "col_end": 32, "sample_pos": {"line": 181, "character": 0}}, {"hash": "b46f8208ca17809e", "line": 181, "col_start": 32, "col_end": 36, "sample_pos": {"line": 181, "character": 32}}, {"hash": "d7064e63adc3d44c", "line": 181, "col_start": 36, "col_end": 53, "sample_pos": {"line": 181, "character": 36}}, {"hash": "439acedc0ff24ddd", "line": 182, "col_start": 0, "col_end": 9, "sample_pos": {"line": 182, "character": 0}}, {"hash": "4e4a0aa986a6d300", "line": 182, "col_start": 9, "col_end": 18, "sample_pos": {"line": 182, "character": 9}}, {"hash": "4e4a0aa986a6d300", "line": 183, "col_start": 0, "col_end": 9, "sample_pos": {"line": 183, "character": 0}}, {"hash": "349c4e938b78daf0", "line": 183, "col_start": 9, "col_end": 18, "sample_pos": {"line": 183, "character": 9}}, {"hash": "349c4e938b78daf0", "line": 184, "col_start": 0, "col_end": 5, "sample_pos": {"line": 184, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 184, "col_start": 5, "col_end": 13, "sample_pos": {"line": 184, "character": 5}}, {"hash": "d7064e63adc3d44c", "line": 186, "col_start": 0, "col_end": 46, "sample_pos": {"line": 186, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 187, "col_start": 0, "col_end": 60, "sample_pos": {"line": 187, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 188, "col_start": 0, "col_end": 16, "sample_pos": {"line": 188, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 189, "col_start": 0, "col_end": 40, "sample_pos": {"line": 189, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 190, "col_start": 0, "col_end": 30, "sample_pos": {"line": 190, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 191, "col_start": 0, "col_end": 17, "sample_pos": {"line": 191, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 192, "col_start": 0, "col_end": 50, "sample_pos": {"line": 192, "character": 0}}, {"hash": "4a18d01fce05380e", "line": 199, "col_start": 54, "col_end": 56, "sample_pos": {"line": 199, "character": 54}}, {"hash": "4a18d01fce05380e", "line": 200, "col_start": 0, "col_end": 3, "sample_pos": {"line": 200, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 200, "col_start": 3, "col_end": 11, "sample_pos": {"line": 200, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 201, "col_start": 0, "col_end": 2, "sample_pos": {"line": 201, "character": 0}}, {"hash": "4a18d01fce05380e", "line": 201, "col_start": 2, "col_end": 3, "sample_pos": {"line": 201, "character": 2}}, {"hash": "9c046f2ee91fa5a0", "line": 201, "col_start": 3, "col_end": 36, "sample_pos": {"line": 201, "character": 3}}, {"hash": "9c046f2ee91fa5a0", "line": 202, "col_start": 0, "col_end": 3, "sample_pos": {"line": 202, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 202, "col_start": 3, "col_end": 13, "sample_pos": {"line": 202, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 204, "col_start": 0, "col_end": 2, "sample_pos": {"line": 204, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 205, "col_start": 0, "col_end": 81, "sample_pos": {"line": 205, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 206, "col_start": 0, "col_end": 44, "sample_pos": {"line": 206, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 207, "col_start": 0, "col_end": 2, "sample_pos": {"line": 207, "character": 0}}, {"hash": "2f85c17004ccf947", "line": 208, "col_start": 48, "col_end": 50, "sample_pos": {"line": 208, "character": 48}}, {"hash": "2f85c17004ccf947", "line": 209, "col_start": 0, "col_end": 3, "sample_pos": {"line": 209, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 209, "col_start": 3, "col_end": 11, "sample_pos": {"line": 209, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 210, "col_start": 0, "col_end": 2, "sample_pos": {"line": 210, "character": 0}}, {"hash": "2f85c17004ccf947", "line": 210, "col_start": 2, "col_end": 3, "sample_pos": {"line": 210, "character": 2}}, {"hash": "d7064e63adc3d44c", "line": 210, "col_start": 3, "col_end": 28, "sample_pos": {"line": 210, "character": 3}}, {"hash": "052e79d7df0e3f68", "line": 226, "col_start": 82, "col_end": 84, "sample_pos": {"line": 226, "character": 82}}, {"hash": "052e79d7df0e3f68", "line": 227, "col_start": 0, "col_end": 64, "sample_pos": {"line": 227, "character": 0}}, {"hash": "052e79d7df0e3f68", "line": 228, "col_start": 0, "col_end": 3, "sample_pos": {"line": 228, "character": 0}}, {"hash": "903335d5c923e5f6", "line": 228, "col_start": 3, "col_end": 9, "sample_pos": {"line": 228, "character": 3}}, {"hash": "903335d5c923e5f6", "line": 229, "col_start": 0, "col_end": 3, "sample_pos": {"line": 229, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 229, "col_start": 3, "col_end": 19, "sample_pos": {"line": 229, "character": 3}}, {"hash": "d7064e63adc3d44c", "line": 232, "col_start": 0, "col_end": 105, "sample_pos": {"line": 232, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 233, "col_start": 0, "col_end": 68, "sample_pos": {"line": 233, "character": 0}}, {"hash": "d7064e63adc3d44c", "line": 234, "col_start": 0, "col_end": 73, "sample_pos": {"line": 234, "character": 0}}]}</script>
<script>
  // ---- Data ----
  const trace = JSON.parse(document.getElementById("trace-data").textContent);
  const unique = trace.unique_states;
  const occs = trace.occurrences;
  const sortedOccs = [...occs].sort((a, b) => (a.line - b.line) || (a.col_start - b.col_start));

  // Build per-line occurrence lists for fast lookup
  const byLine = new Map();
  for (const o of occs) {
    const ln = o.line;
    if (!byLine.has(ln)) byLine.set(ln, []);
    byLine.get(ln).push(o);
  }
  for (const [ln, arr] of byLine.entries()) {
    arr.sort((a,b) => (a.col_start - b.col_start) || (a.col_end - b.col_end));
  }

  // ---- Render code with line numbers + spans ----
  const codewrap = document.getElementById("codewrap");
  const cursorEl = document.getElementById("cursor");

  const src = "import Mathlib.Data.Setoid.Basic\nimport Mathlib.Data.Setoid.Partition\nopen Function\n\n/-\nAlgebra Chapter 0. I.1.2\n\nProve that if ∼ is an equivalence relation on a set S, then the corresponding\nfamily P∼ defined in §1.5 is indeed a partition of S: that is, its elements are\nnonempty, disjoint, and their union is S. [§1.5]\n-/\n\ntheorem setoid_trans (r : Setoid a) (x y z : a) (h : (r x y) ∧ (r y z)) : (r x z) := by\n  rcases h with ⟨hP, hQ⟩\n  exact r.trans hP hQ\n\ntheorem setoid_refl (r : Setoid a) : (∀ x : a, r x x) := by\n    exact r.refl\n\ntheorem classes_nonempty (r : Setoid a) : ∅ ∉ r.classes := by\n  simp [Setoid.classes]\n  intro x h\n  -- intro h\n  have hx : x ∈ {x_1 | r x_1 x} := by\n    apply r.refl x\n  have he : x ∈ (∅ : Set a) := by\n    -- simp [hx] at h\n    rw [h]\n    exact hx\n  exact he\n\n/-\nit will be easier to show ∀ a, ∃! b ∈ c, a ∈ b then pw disjoint\n-/\ntheorem classes_pw_disjoint (r : Setoid a) : (r.classes.PairwiseDisjoint id) := by\n  -- simp [Set.PairwiseDisjoint, Set.Pairwise, Disjoint]\n  -- exact r.classes.PairwiseDisjoint id\n  -- simpa using (Setoid.IsPartition.pairwiseDisjoint (hc := Setoid.isPartition_classes r))\n  have hc : Setoid.IsPartition r.classes := Setoid.isPartition_classes r\n  simp [Setoid.IsPartition] at hc\n  sorry\n/-\n\nthe general proof is to deconstruct an iff of xe in x -> xe in y and xe in y -> xe in x.\n\nthis is a direct result of the transitivity of r.\n\nwe show that r z a1 and r z a2 => r a1 a2. then since we know xe in x, r xe a1, thus r xe a2.\n\nand vice versa\n\n-/\ntheorem nondisjoint_classes_eq (r : Setoid a) (h1 : x ∈ r.classes) (h2 : y ∈ r.classes)\n  (hz : (z : a) ∈ x ∧ z ∈ y) : x = y := by\n  rcases hz with ⟨inx, iny⟩\n\n  rcases (by simpa [Setoid.classes] using h1) with ⟨a1, rfl⟩\n  rcases (by simpa [Setoid.classes] using h2) with ⟨a2, rfl⟩\n\n  have hzx : r z a1 := by exact inx\n  have hzy : r z a2 := by exact iny\n  have hxy : r a1 a2 := by exact r.trans (r.symm hzx) hzy\n\n  ext xe\n  constructor\n\n  · intro hxe\n    have hxex : r xe a1 := by simpa using hxe\n    change r xe a2\n    exact r.trans hxex hxy\n\n  · intro hxe\n    have hxex : r xe a2 := by simpa using hxe\n    change r xe a1\n    exact r.trans hxex (r.symm hxy)\n\n\ntheorem exists_class (r : Setoid a) :(∀ x : a, ∃ b ∈ r.classes, x ∈ b) := by\n  intro x\n  -- let xc := {z | r z x}\n  -- then show that xc in r.classes and use xc as witness for b\n  use {z | r z x}\n  constructor\n  · rw [Setoid.classes]\n    use x\n  · exact r.refl x\n\ntheorem covers_unique (r : Setoid a) : (∀ x : a, ∃! b ∈ r.classes, x ∈ b) := by\n  intro x\n  rcases exists_class r x with ⟨b, hb_classes, hxb⟩\n  refine ⟨b, ?_, ?_⟩\n  · change b ∈ r.classes ∧ x ∈ b\n    exact ⟨hb_classes, hxb⟩\n  · intro y\n    simp\n    intro hy hxe\n    exact nondisjoint_classes_eq r hy hb_classes ⟨hxe, hxb⟩\n\ntheorem setoid_is_partition (r : Setoid a) : Setoid.IsPartition r.classes := by\n  rw [Setoid.IsPartition]\n  constructor\n  · exact classes_nonempty r\n  · exact covers_unique r\n\n\nsection right_inv_imp_surjective\n/-\nACh0: I.2.2\n\n2.2.  Prove statement (2) in Proposition 2.1. You may assume that given a family\nof disjoint nonempty subsets of a set, there is a way to choose one element in each\nmember of the family13. [§2.5, V.3.3]\n\nProposition 2.1. Assume A = ∅, and let f : A → B be a function. Then\n(1) f has a left-inverse if and only if it is injective.\n(2) f has a right-inverse if and only if it is surjective.\n\n\n(1)\n  =>) if has left inv then g circ f = id_A\n    a1 and a2 in A then gf(a1) = a1 gf(a2) = a2 so gf(a1) = gf(a2) only if a1=a2 (defn of injective)\n\n-/\n\n/-\n\nthis version of the proof attempts to use as much mathlib as possible\n-/\ntheorem mathlib_inj_iff_has_left_inv (f : A -> B) [Nonempty A]\n  : Injective f ↔ HasLeftInverse f := by\n  constructor\n  · sorry\n  . exact Function.HasLeftInverse.injective\n\n\n/-\nusing less mathlib\n-/\ntheorem mathlib_inj_iff_has_left_inv2 (f : A -> B) (hne: Nonempty A)\n  : Injective f ↔ HasLeftInverse f := by\n  constructor\n  · classical\n    intro hinj\n    -- so since a ≠ a' => f a ≠ f a' for each a in A, we can define g(f(a)) = a\n    -- this satisfies the definition of a partial left inverse. so then since f is not\n    -- guaranteed to be surjective, we choose an arbitrary element of a to send (B \\ im f) to\n    let g : B -> A :=\n     fun b => dite (∃ a, f a = b)\n              (fun h => Classical.choose h)\n              (fun _ => Classical.choice hne)\n    -- now we just need to show the left inverse property\n    -- that ∀a g(f(a)) = a and that g is a total function\n    -- g is already proved to be total, otherwise we could not construct a term of type B->A\n    -- now all we need to do is show the left inv prop.\n    refine ⟨g, ?_⟩\n    intro a\n    have hex : ∃ a' : A, f a' = f a := ⟨a, rfl⟩\n\n  -- unfold g at (f a) and reduce the `dite`/`if` using hex\n  -- after simp: goal becomes Classical.choose hex = a\n    have blorp : Classical.choose hex = a := by\n      apply hinj\n      -- choose_spec hex : f (choose hex) = f a\n      simpa using (Classical.choose_spec hex)\n\n    -- now finish\n    simp [g, hex, blorp]\n  .\n    -- we know that for all a in A g(f(a)) = a. this is hg. (definition of left inv)\n    -- then the hypothesis of injectivity is that we have two elements a1 and a2 with the same image\n    -- we assume then f a1 = f a2. to show that f is injective we need to show that a1 = a2\n    -- since we also know that (g circ f) (a) = a = g(f(a))\n    -- we can apply g to both sides and apply the left inverse identity to get g(f(a1)) = g(f(a2))\n    -- then a1 and a2 must have been equal\n\n    intro hl\n    obtain ⟨g, hg⟩ := hl\n    have hg_ := hg\n    rw [LeftInverse] at hg\n    rw [Injective]\n    intros a1 a2 hf\n    have foo : a1 = g (f a1) := by exact (hg a1).symm\n    rw [hf] at foo\n    rw [hg] at foo\n    exact foo\n\n-- theorem inj_iff_has_left_inv (f : A -> B) :\n--   Function.Injective f ↔ ∃ (g : B -> A), g ∘ f = id := by\n--   constructor\n--   -- =>) injectivity implies left inv\n--   · rw [Function.Injective]\n--     intro finj\n--     exact Function.Injective.exists_leftInverse\n\nend right_inv_imp_surjective\n\n/-\ntheorem demonstrating Classical.choose\n-/\ntheorem hasa_prop (h : ∃ _ : A, True) : Nonempty A := by\n  classical\n  have foo : A := Classical.choose h\n  exact ⟨foo⟩\n\n/-\nexample showing how to use a element from nonempty type (via choice, not choose!)\nnot sure whats up exactly with noncomputable\n-/\nnoncomputable example (hne : Nonempty A) : A := by\n  classical\n  exact Classical.choice hne\n\n\n#check some 3\n\n\n\n/-\nfollowing is one way to show that for a left inv g of f that g is surjective\n  -- assume for contradiction that there is an a ∈ A st ∄b, g(b) = a (thus g not surj)\n  -- then by definition of left inverse g(f(x)) = id_A, so such an a dne\n\nbut it is far easier to take a as any elt of A, then use (f a) as the witness for existential\nthen the definition of left inv gives a proof that this g (f a) = a.\nsince a was arbitrary, g is surjective.\n-/\ntheorem g_surj_if_left_inv (f : A -> B) (h : LeftInverse g f) : (Surjective g) := by\n  -- have finj : Injective f := by exact LeftInverse.injective h\n  intro a\n  refine ⟨f a, h a⟩\n\n\n-- theorem inv_bij_is_bij (f : A -> B) (hl : LeftInverse g f) (hr : RightInverse g f) : Bijective g := by\n--   have finj : Injective f := by exact (LeftInverse.injective g f)\n--   have fsurj : Surjective f  := by exact (RightInverse.surjective g f)\n";
  const lines = src.split(/\n/);

  function escapeHtml(s) {
    return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
            .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  // Register a small Lean grammar for highlight.js if not bundled
  (function registerLean() {
    if (window.hljs && !hljs.getLanguage("lean")) {
      hljs.registerLanguage("lean", function(hljs) {
        return {
          name: "Lean",
          aliases: ["lean4"],
          keywords: {
            keyword:
              "theorem lemma def example structure class instance inductive mutual namespace end open section variable variables abbrev macro notation do fun match with if then else by simp rw intro intros exact apply refine have let in where forall ∀ exists ∃ return continue break cases constructor revert rename_i repeat try first focus set_option axiom constant",
            built_in:
              "Type Sort Prop true false Bool Nat Int Rat Real List Array Set Option",
          },
          contains: [
            hljs.COMMENT("--", "$"),
            hljs.COMMENT("/-", "-/"),
            hljs.QUOTE_STRING_MODE,
            hljs.NUMBER_MODE,
          ],
        };
      });
    }
  })();

  function highlightLean(text, opts = {}) {
    if (opts.forceComment) {
      return `<span class="hljs-comment">${escapeHtml(text)}</span>`;
    }
    if (!window.hljs) return escapeHtml(text);
    try {
      const res = hljs.highlight(text, { language: "lean", ignoreIllegals: true });
      return res.value || "";
    } catch (e) {
      return escapeHtml(text);
    }
  }

  function nextBlockState(text, inBlock) {
    let state = inBlock;
    for (let i = 0; i < text.length; i++) {
      if (!state && text[i] === "/" && text[i + 1] === "-") {
        state = true;
        i++;
      } else if (state && text[i] === "-" && text[i + 1] === "/") {
        state = false;
        i++;
      }
    }
    return state;
  }

  function renderLine(ln, text, inBlockComment) {
    const trimmed = text.trimStart();
    const isLineComment = trimmed.startsWith("--");
    const forceComment = inBlockComment || isLineComment;

    const occList = byLine.get(ln) || [];
    const safeHighlight = (snippet) => {
      if (snippet.length === 0) return " ";
      return highlightLean(snippet, { forceComment });
    };

    if (occList.length === 0) {
      return {
        html: `<span class="line" data-ln="${ln}"><span class="ln">${(ln+1).toString().padStart(4,' ')}</span><span class="codeText">${safeHighlight(text)}</span></span>`,
        nextBlock: nextBlockState(text, inBlockComment),
      };
    }

    let cur = 0;
    let out = "";
    for (const o of occList) {
      const a = Math.max(0, Math.min(text.length, o.col_start));
      const b = Math.max(0, Math.min(text.length, o.col_end));
      if (a > cur) out += safeHighlight(text.slice(cur, a));
      const segText = safeHighlight(text.slice(a, b));
      const hasGoal = unique[o.hash] && unique[o.hash] !== "no goals";
      out += `<span class="seg ${hasGoal ? "hasGoal" : ""}" data-h="${o.hash}" data-ln="${ln}" data-a="${a}" data-b="${b}">${segText || " "}</span>`;
      cur = b;
    }
    if (cur < text.length) out += safeHighlight(text.slice(cur));

    return {
      html: `<span class="line" data-ln="${ln}"><span class="ln">${(ln+1).toString().padStart(4,' ')}</span><span class="codeText">${out}</span></span>`,
      nextBlock: nextBlockState(text, inBlockComment),
    };
  }

  // Inject all lines, tracking block comments so comment text stays un-highlighted
  const pre = document.createElement("pre");
  const code = document.createElement("code");
  code.className = "language-lean"; // may fall back, still fine
  let blockComment = false;
  const rendered = [];
  for (let i = 0; i < lines.length; i++) {
    const res = renderLine(i, lines[i], blockComment);
    rendered.push(res.html);
    blockComment = res.nextBlock;
  }
  code.innerHTML = rendered.join("");
  pre.appendChild(code);
  codewrap.appendChild(pre);

  // ---- Cursor model ----
  let curLine = 0;
  let curCol = 0;
  let activeSeg = null;
  let activeFallback = false;

  function setActiveSeg(seg, isFallback=false) {
    if (activeSeg) activeSeg.classList.remove("active", "fallback");
    activeSeg = seg;
    activeFallback = isFallback;
    if (activeSeg) {
      activeSeg.classList.add("active");
      if (isFallback) activeSeg.classList.add("fallback");
    }
  }

  function lookupOccurrence(line, col) {
    const arr = byLine.get(line);
    if (!arr) return null;
    // Linear scan is OK for small lists; can binary-search later.
    for (const o of arr) {
      if (col >= o.col_start && col < o.col_end) return o;
    }
    return null;
  }

  function lookupWithFallback(line, col) {
    const hit = lookupOccurrence(line, col);
    if (hit) return { occ: hit, viaFallback: false };

    // binary search across all occurrences to find the last one that starts before (line,col)
    let lo = 0, hi = sortedOccs.length;
    while (lo < hi) {
      const mid = (lo + hi) >> 1;
      const o = sortedOccs[mid];
      if (o.line < line || (o.line === line && o.col_start <= col)) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    if (lo === 0) return null;
    return { occ: sortedOccs[lo - 1], viaFallback: true };
  }

  function renderGoalForPos(line, col) {
    const res = lookupWithFallback(line, col);
    if (!res) {
      document.getElementById("where").textContent = `line=${line+1} col=${col} (no cached goal here)`;
      document.getElementById("goal").textContent = "(no cached goal here)";
      setActiveSeg(null);
      return;
    }
    const o = res.occ;
    const txt = unique[o.hash] ?? "(missing)";
    const whereLabel = res.viaFallback
      ? `cursor=(${line+1},${col})  fallback→ line=${o.line+1} cols=[${o.col_start},${o.col_end}) hash=${o.hash}`
      : `hash=${o.hash}  line=${o.line+1}  cols=[${o.col_start},${o.col_end})  cursor=(${line+1},${col})`;
    document.getElementById("where").textContent = whereLabel;
    document.getElementById("goal").textContent = txt;

    // highlight the segment if we can find it
    const seg = document.querySelector(`.seg[data-h="${o.hash}"][data-ln="${o.line}"][data-a="${o.col_start}"][data-b="${o.col_end}"]`);
    setActiveSeg(seg, res.viaFallback);
  }

  function colFromClick(lineEl, clientX, clientY) {
    const caretPos = (document.caretPositionFromPoint && document.caretPositionFromPoint(clientX, clientY))
      || (document.caretRangeFromPoint && document.caretRangeFromPoint(clientX, clientY));
    if (!caretPos) return 0;
    const node = caretPos.offsetNode || caretPos.startContainer;
    const offset = caretPos.offset ?? caretPos.startOffset ?? 0;
    if (!node || !lineEl.contains(node)) return 0;

    let col = 0;
    const walker = document.createTreeWalker(lineEl, NodeFilter.SHOW_TEXT, null);
    while (walker.nextNode()) {
      const n = walker.currentNode;
      if (n === node) {
        col += Math.min(offset, n.nodeValue.length);
        break;
      }
      col += n.nodeValue.length;
    }
    return col;
  }

  function placeCursor(line, col) {
    curLine = Math.max(0, Math.min(lines.length - 1, line));
    curCol = Math.max(0, col);

    // Find the DOM element representing this line
    const lineEl = document.querySelector(`.line[data-ln="${curLine}"] .codeText`);
    if (!lineEl) return;

    // Measure character position by creating a range to that offset.
    // This is imperfect with tabs and multi-width glyphs; good enough for typical Lean.
    const text = lines[curLine] || "";
    const clamped = Math.min(curCol, text.length);

    // Create a temporary span to position cursor
    const range = document.createRange();

    // We need a text node position. We'll walk text nodes under .codeText.
    let remaining = clamped;
    let foundNode = null;
    let foundOffset = 0;

    const walker = document.createTreeWalker(lineEl, NodeFilter.SHOW_TEXT, null);
    while (walker.nextNode()) {
      const node = walker.currentNode;
      const len = node.nodeValue.length;
      if (remaining <= len) {
        foundNode = node;
        foundOffset = remaining;
        break;
      }
      remaining -= len;
    }

    if (!foundNode) {
      // place at end
      foundNode = lineEl.lastChild;
      foundOffset = (foundNode && foundNode.nodeType === Node.TEXT_NODE) ? foundNode.nodeValue.length : 0;
    }

    try {
      range.setStart(foundNode, foundOffset);
      range.setEnd(foundNode, foundOffset);
      const rects = range.getClientRects();
      const rect = rects.length ? rects[0] : lineEl.getBoundingClientRect();

      const wrapRect = codewrap.getBoundingClientRect();
      cursorEl.style.left = (rect.left - wrapRect.left + codewrap.scrollLeft) + "px";
      cursorEl.style.top = (rect.top - wrapRect.top + codewrap.scrollTop) + "px";
      cursorEl.style.height = rect.height + "px";
      cursorEl.style.display = "block";
    } catch (e) {
      // fallback: hide cursor if range fails
      cursorEl.style.display = "none";
    }

    renderGoalForPos(curLine, curCol);
  }

  // ---- Mouse: click places cursor ----
  codewrap.addEventListener("click", (ev) => {
    codewrap.focus();
    const lineEl = ev.target.closest(".line");
    if (lineEl) {
      const ln = parseInt(lineEl.dataset.ln);
      const codeEl = lineEl.querySelector(".codeText");
      const col = codeEl ? colFromClick(codeEl, ev.clientX, ev.clientY) : 0;
      placeCursor(ln, col);
    }
  });

  // ---- Keyboard: arrow keys move cursor ----
  codewrap.addEventListener("keydown", (ev) => {
    const key = ev.key;
    if (key === "ArrowUp") {
      ev.preventDefault();
      const newLine = Math.max(0, curLine - 1);
      const newCol = Math.min(curCol, (lines[newLine] || "").length);
      placeCursor(newLine, newCol);
    } else if (key === "ArrowDown") {
      ev.preventDefault();
      const newLine = Math.min(lines.length - 1, curLine + 1);
      const newCol = Math.min(curCol, (lines[newLine] || "").length);
      placeCursor(newLine, newCol);
    } else if (key === "ArrowLeft") {
      ev.preventDefault();
      if (curCol > 0) {
        placeCursor(curLine, curCol - 1);
      } else if (curLine > 0) {
        const newLine = curLine - 1;
        placeCursor(newLine, (lines[newLine] || "").length);
      }
    } else if (key === "ArrowRight") {
      ev.preventDefault();
      const lineText = lines[curLine] || "";
      if (curCol < lineText.length) {
        placeCursor(curLine, curCol + 1);
      } else if (curLine < lines.length - 1) {
        placeCursor(curLine + 1, 0);
      }
    }
  });

  // Start cursor at (0,0)
  placeCursor(0, 0);

  // Theme toggle
  const body = document.body;
  const toggle = document.getElementById("themeToggle");
  function applyTheme(t) {
    body.classList.remove("theme-light", "theme-dark");
    body.classList.add(`theme-${t}`);
    localStorage.setItem("lean-theme", t);
  }
  const savedTheme = localStorage.getItem("lean-theme");
  if (savedTheme === "dark" || savedTheme === "light") {
    applyTheme(savedTheme);
  } else {
    applyTheme(window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
  }
  toggle.addEventListener("click", () => {
    const next = body.classList.contains("theme-dark") ? "light" : "dark";
    applyTheme(next);
  });
</script>
</body>
</html>
